#include "FilePropertiesManager.hh"
#include "HistUtils.hh"
#include "UniverseMaker.hh"

#include "TParameter.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TLine.h"
#include "TFile.h"

// Script intended to help with choosing binning for kinematic variables

// The anticipated POT to use when scaling the MC prediction in the expected
// reco events plot. This will help ensure that all choices of reco binning
// are informed by the expected statistical uncertainties when the full dataset
// is analyzed.
constexpr double EXPECTED_POT = 6.790e20; // Full dataset for Runs 1-3

// Number of true bins to use when plotting true distributions in a given
// reco bin
constexpr int DEFAULT_TRUE_BINS = 100;

// ROOT integer code for Arial font
constexpr int FONT_STYLE = 62; // Arial

// When bins have zero content, set them to this very small value so that the
// colz style will still paint them
constexpr double REALLY_SMALL = 1e-11;


void make_res_plots( const std::string& branchexpr,
  const std::string& variable_title, const std::string& selection,
  const std::set<int>& runs, std::vector<double> bin_low_edges,
  bool show_bin_plots = true,
  bool show_smear_numbers = false,
  int num_true_bins = DEFAULT_TRUE_BINS,
  const std::string& mc_branchexpr = "",
  const std::string& signal_cuts = "CC1mu2p0pi_MC_Signal",
  const std::string& mc_event_weight = DEFAULT_MC_EVENT_WEIGHT )
{
  // Get the outer edges of the reco-space bins. This will be used to set the
  // plot range for the true-space histograms.
  double xmin = bin_low_edges.front();
  double xmax = bin_low_edges.back();

  // If the user hasn't explicitly specified a branch expression for the
  // true quantity, assume that it's the same as the reco quantity but
  // with the prefix "mc_" added.
  std::string true_branchexpr = mc_branchexpr;
  if ( true_branchexpr.empty() ) {
    true_branchexpr = "mc_" + branchexpr;
  }

  // Get access to the singleton utility class that manages the processed
  // ntuple files
  const FilePropertiesManager& fpm = FilePropertiesManager::Instance();

  // Make a TChain to process the CV numu ntuples from the requested run(s).
  // For the resolution studies, this is all we really need. Add the
  // appropriate ntuples to the TChain. Also tally the total simulated
  // POT for later scaling purposes.
  TChain chain( "stv_tree" );
  double total_simulated_POT = 0.;

  const auto& ntuple_map = fpm.ntuple_file_map();
  for ( const auto& run : runs ) {
    const auto& ntuple_files = ntuple_map.at( run )
      .at( NtupleFileType::kNumuMC );
    for ( const auto& file_name : ntuple_files ) {
      chain.Add( file_name.c_str() );

      TFile temp_file( file_name.c_str(), "read" );
      TParameter<float>* temp_pot = nullptr;
      temp_file.GetObject( "summed_pot", temp_pot );
      double pot = temp_pot->GetVal();
      total_simulated_POT += pot;
    }
  }

  // Dummy counter used to ensure that each histogram generated by this
  // function has a unique name to use with TTree::Draw()
  static int hist_count = 0;

  if ( show_bin_plots ) {
    for ( size_t b = 1u; b < bin_low_edges.size(); ++b ) {
      ++hist_count;

      TCanvas* c = new TCanvas;
      std::string true_hist_name = "true_hist" + std::to_string( hist_count );

      TH1D* true_hist = new TH1D( true_hist_name.c_str(),
        ("true events in " + variable_title + " reco bin "
        + std::to_string(b) + "; " + variable_title + "; events").c_str(),
        num_true_bins, xmin, xmax );

      double reco_bin_min = bin_low_edges.at( b - 1 );
      double reco_bin_max = bin_low_edges.at( b );
      std::string cuts = mc_event_weight + " * (is_mc && " + signal_cuts
        + " && " + selection + " && " + branchexpr + " >= "
        + std::to_string( reco_bin_min ) + " && " + branchexpr
        + " < " + std::to_string( reco_bin_max ) + ')';

      chain.Draw( (true_branchexpr + " >> " + true_hist_name).c_str(),
        cuts.c_str(), "goff" );

      true_hist->SetStats( false );
      true_hist->SetLineWidth( 2 );
      true_hist->SetLineColor( kBlack );

      true_hist->Draw( "hist pe" );

      // Prepare vertical lines to draw on the plot. These will show the
      // boundaries of the reco bin in true space
      double max_for_lines = std::numeric_limits<double>::max();

      TLine* line_bin_min = new TLine( reco_bin_min, 0.,
        reco_bin_min, max_for_lines );

      TLine* line_bin_max = new TLine( reco_bin_max, 0.,
        reco_bin_max, max_for_lines );

      line_bin_min->SetLineColor( kRed );
      line_bin_min->SetLineWidth( 2 );
      line_bin_min->SetLineStyle( 1 );
      line_bin_min->Draw( "same" );

      line_bin_max->SetLineColor( kRed );
      line_bin_max->SetLineWidth( 2 );
      line_bin_max->SetLineStyle( 1 );
      line_bin_max->Draw( "same" );

    } // loop over reco bins

  } // show bin plots

  // Also get the total number of reco bins for the 2D smearing plot
  int num_reco_bins = bin_low_edges.size() - 1u;

  // Compute the smearing matrix for a choice of true bins that exactly
  // match the ones in reco space.
  std::string smear_hist_name = "smear_hist" + std::to_string( hist_count );
  TH2D* smear_hist = new TH2D( smear_hist_name.c_str(),
    ("smearing matrix for " + variable_title + "; true " + variable_title
    + "; reco " + variable_title).c_str(), num_reco_bins, bin_low_edges.data(),
    num_reco_bins, bin_low_edges.data() );

  std::string smear_expr = branchexpr + " : " + true_branchexpr
    + " >> " + smear_hist_name;

  std::string smear_cuts = mc_event_weight + " * (is_mc && " + signal_cuts
    + " && " + selection + ')';

  chain.Draw( smear_expr.c_str(), smear_cuts.c_str(), "goff" );

  // Before renormalizing the smearing matrix histogram, take a projection
  // along the reco (y) axis. This will show the expected number of signal
  // events in each reco bin according to our central value MC model. Reco bins
  // should be chosen to have sufficient expected statistics in addition to
  // small smearing.
  TH1D* expected_reco_hist = smear_hist->ProjectionY();

  // Scale the expected reco bin counts to the POT analyzed for the full
  // dataset. Also set the bin stat uncertainties to the square root of their
  // contents. This is not correct for getting the MC statistical uncertainties
  // (which should use the sum of the squares of the weights to get the
  // variance), but we're less interested in those. Primarily we'd like to know
  // what the anticipated statistical uncertainties on the *measurement* will
  // be. We can estimate that by choosing the bin errors in this way. This will
  // help in the effort to choose suitable bins for reporting the final result.
  expected_reco_hist->Scale( EXPECTED_POT / total_simulated_POT );
  for ( int eb = 0; eb <= num_reco_bins + 1; ++eb ) {
    double bin_events = expected_reco_hist->GetBinContent( eb );
    double bin_stat_err = std::sqrt( std::max(0., bin_events) );
    expected_reco_hist->SetBinError( eb, bin_stat_err );
  }

  expected_reco_hist->SetStats( false );
  expected_reco_hist->SetLineColor( kBlack );
  expected_reco_hist->SetLineWidth( 2 );

  std::stringstream temp_ss;
  temp_ss << "expected reco bin counts (" << EXPECTED_POT << " POT);"
    << " reco " << variable_title << "; events";

  expected_reco_hist->SetTitle( temp_ss.str().c_str() );

  TCanvas* c_expected = new TCanvas;
  expected_reco_hist->Draw( "hist e" );

  // Normalize the smearing matrix elements so that a sum over all reco bins
  // (including the under/overflow bins) yields a value of one. This means that
  // every selected signal event must end up somewhere in reco space.
  int num_bins_x = smear_hist->GetXaxis()->GetNbins();
  int num_bins_y = smear_hist->GetYaxis()->GetNbins();

  // Loop over the true (x) bins. Include the underflow (index zero) and
  // overflow (index num_bins_x + 1) bins.
  for ( int bx = 0; bx <= num_bins_x + 1; ++bx ) {

    // For the current true (x) bin, compute the sum of all reco (y) bins.
    double y_sum = 0.;
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {
      y_sum += smear_hist->GetBinContent( bx, by );
    }

    // Normalize each of the reco (y) bins so that the sum over y is unity.
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {

      // To avoid dividing by zero, set the bin content to zero if the sum of
      // the reco (y) bins is not positive.
      if ( y_sum <= 0. ) {
        //smear_hist->SetBinContent( bx, by, REALLY_SMALL );
        smear_hist->SetBinContent( bx, by, 0. );
      }
      else {
        // Otherwise, normalize in the usual way
        double bc = smear_hist->GetBinContent( bx, by );

        double content = std::max( bc / y_sum, REALLY_SMALL );

        smear_hist->SetBinContent( bx, by, content );
      }
    } // loop over reco (y) bins

  } // loop over true (x) bins

  // Smearing matrix histogram style options
  smear_hist->GetXaxis()->SetTitleFont( FONT_STYLE);
  smear_hist->GetYaxis()->SetTitleFont( FONT_STYLE );
  smear_hist->GetXaxis()->SetTitleSize( 0.05 );
  smear_hist->GetYaxis()->SetTitleSize( 0.05 );
  smear_hist->GetXaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetYaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelSize( 0.03 );
  smear_hist->GetXaxis()->CenterTitle();
  smear_hist->GetYaxis()->CenterTitle();
  smear_hist->GetXaxis()->SetTitleOffset( 1.2 );
  smear_hist->GetYaxis()->SetTitleOffset( 1.1 );
  smear_hist->SetStats( false );
  smear_hist->SetMarkerSize( 1.8 ); // text size
  smear_hist->SetMarkerColor( kWhite ); // text color

  // Draw the smearing matrix plot
  TCanvas* c_smear = new TCanvas;
  c_smear->SetBottomMargin( 0.15 );
  c_smear->SetLeftMargin( 0.13 );

  if ( show_smear_numbers ) {
    // Round all numbers to this precision when rendering them
    gStyle->SetPaintTextFormat( "4.2f" );

    smear_hist->Draw("text colz");
  }
  else {
    smear_hist->Draw( "colz" );
  }

  std::cout << "variable_title:" << variable_title << std::endl;
  // For each true bin, print the fraction of events that are reconstructed
  // in the correct corresponding reco bin.
  for ( int bb = 1; bb <= num_reco_bins; ++bb ) {
    std::cout << "bin #" << bb << ": "
	      << expected_reco_hist->GetBinLowEdge( bb ) << " -> " << expected_reco_hist->GetBinLowEdge( bb+1 ) << " , "
	      << smear_hist->GetBinContent(bb, bb) << '\n';
  }
  std::cout << std::endl;

  delete smear_hist;
}

// Overloaded version that uses a fixed number of equal-width bins
void make_res_plots( const std::string& branchexpr,
  const std::string& variable_title, const std::string& selection,
  const std::set<int>& runs,
  double xmin, double xmax, int Nbins,
  bool show_bin_plots = true,
  bool show_smear_numbers = false,
  int num_true_bins = DEFAULT_TRUE_BINS,
  const std::string& mc_branchexpr = "",
  const std::string& signal_cuts = "mc_is_signal",
  const std::string& mc_event_weight = DEFAULT_MC_EVENT_WEIGHT )
{
  auto low_edges = get_bin_low_edges( xmin, xmax, Nbins );
  return make_res_plots( branchexpr, variable_title, selection, runs,
    low_edges, show_bin_plots, show_smear_numbers, num_true_bins,
    mc_branchexpr, signal_cuts, mc_event_weight );
}

void make_res_plots( const std::string& rmm_config_file_name,
  const std::set<int>& runs,
  const std::string& universe_branch_name = "TunedCentralValue_UBGenie",
  size_t universe_index = 0u,
  bool show_smear_numbers = false )
{
  const std::string variable_title = "bin";

  // Create a UniverseMaker object that will handle the actual
  // calculation of the smearing matrix
  UniverseMaker rmm( rmm_config_file_name );

  // Get access to the singleton utility class that manages the processed
  // ntuple files
  const FilePropertiesManager& fpm = FilePropertiesManager::Instance();

  // TODO: Reduce code duplication for the POT tallying

  // Add the appropriate CV numu ntuples from the requested run(s) to the
  // TChain owned by the UniverseMaker object. For the resolution
  // studies, this is all we really need. Also tally the total simulated POT
  // for later scaling purposes.
  double total_simulated_POT = 0.;

  const auto& ntuple_map = fpm.ntuple_file_map();
  for ( const auto& run : runs ) {
    const auto& ntuple_files = ntuple_map.at( run )
      .at( NtupleFileType::kNumuMC );
    for ( const auto& file_name : ntuple_files ) {
      rmm.add_input_file( file_name );

      TFile temp_file( file_name.c_str(), "read" );
      TParameter<float>* temp_pot = nullptr;
      temp_file.GetObject( "summed_pot", temp_pot );
      double pot = temp_pot->GetVal();
      total_simulated_POT += pot;
    }
  }

  // Look up the MC event weights from the input files and construct the
  // response matrices in the usual way. For speed, restrict the calculation to
  // just the universe branch requested by the user (typically the CV branch).
  rmm.build_universes( { universe_branch_name } );

  // For all but the "unweighted" universe, the key used to look up
  // the map entry is "weight_" prepended to the original ntuple branch name.
  std::string universe_key = "unweighted";
  if ( universe_key != universe_branch_name ) {
    universe_key = "weight_" + universe_branch_name;
  }

  // Get access to the Universe object that stores the histograms of summed MC
  // event weights that we need
  const auto& universe = rmm.universe_map().at( universe_key )
    .at( universe_index );

  TH2D* smear_hist = dynamic_cast< TH2D* >(
    universe.hist_2d_->Clone("smear_hist") );

  // TODO: also reduce code duplication here

  // Before renormalizing the smearing matrix histogram, take a projection
  // along the reco (y) axis. This will show the expected number of signal
  // events in each reco bin according to our central value MC model. Reco bins
  // should be chosen to have sufficient expected statistics in addition to
  // small smearing.
  TH1D* expected_reco_hist = smear_hist->ProjectionY();
  int num_reco_bins = expected_reco_hist->GetNbinsX();

  // Scale the expected reco bin counts to the POT analyzed for the full
  // dataset. Also set the bin stat uncertainties to the square root of their
  // contents. This is not correct for getting the MC statistical uncertainties
  // (which should use the sum of the squares of the weights to get the
  // variance), but we're less interested in those. Primarily we'd like to know
  // what the anticipated statistical uncertainties on the *measurement* will
  // be. We can estimate that by choosing the bin errors in this way. This will
  // help in the effort to choose suitable bins for reporting the final result.
  expected_reco_hist->Scale( EXPECTED_POT / total_simulated_POT );
  for ( int eb = 0; eb <= num_reco_bins + 1; ++eb ) {
    double bin_events = expected_reco_hist->GetBinContent( eb );
    double bin_stat_err = std::sqrt( std::max(0., bin_events) );
    expected_reco_hist->SetBinError( eb, bin_stat_err );
  }

  expected_reco_hist->SetStats( false );
  expected_reco_hist->SetLineColor( kBlack );
  expected_reco_hist->SetLineWidth( 2 );

  std::stringstream temp_ss;
  temp_ss << "expected reco bin counts (" << EXPECTED_POT << " POT);"
    << " reco " << variable_title << "; events";

  expected_reco_hist->SetTitle( temp_ss.str().c_str() );

  TCanvas* c_expected = new TCanvas;
  expected_reco_hist->Draw( "hist e" );

  // Normalize the smearing matrix elements so that a sum over all reco bins
  // (including the under/overflow bins) yields a value of one. This means that
  // every selected signal event must end up somewhere in reco space.
  int num_bins_x = smear_hist->GetXaxis()->GetNbins();
  int num_bins_y = smear_hist->GetYaxis()->GetNbins();

  // Loop over the true (x) bins. Include the underflow (index zero) and
  // overflow (index num_bins_x + 1) bins.
  for ( int bx = 0; bx <= num_bins_x + 1; ++bx ) {

    // For the current true (x) bin, compute the sum of all reco (y) bins.
    double y_sum = 0.;
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {
      y_sum += smear_hist->GetBinContent( bx, by );
    }

    // Normalize each of the reco (y) bins so that the sum over y is unity.
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {

      // To avoid dividing by zero, set the bin content to zero if the sum of
      // the reco (y) bins is not positive.
      if ( y_sum <= 0. ) {
        //smear_hist->SetBinContent( bx, by, REALLY_SMALL );
        smear_hist->SetBinContent( bx, by, 0. );
      }
      else {
        // Otherwise, normalize in the usual way
        double bc = smear_hist->GetBinContent( bx, by );

        double content = std::max( bc / y_sum, REALLY_SMALL );

        smear_hist->SetBinContent( bx, by, content );
      }
    } // loop over reco (y) bins

  } // loop over true (x) bins

  // Smearing matrix histogram style options
  smear_hist->GetXaxis()->SetTitleFont( FONT_STYLE);
  smear_hist->GetYaxis()->SetTitleFont( FONT_STYLE );
  smear_hist->GetXaxis()->SetTitleSize( 0.05 );
  smear_hist->GetYaxis()->SetTitleSize( 0.05 );
  smear_hist->GetXaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetYaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelSize( 0.03 );
  smear_hist->GetXaxis()->CenterTitle();
  smear_hist->GetYaxis()->CenterTitle();
  smear_hist->GetXaxis()->SetTitleOffset( 1.2 );
  smear_hist->GetYaxis()->SetTitleOffset( 1.1 );
  smear_hist->SetStats( false );
  smear_hist->SetMarkerSize( 1.8 ); // text size
  smear_hist->SetMarkerColor( kWhite ); // text color

  // Draw the smearing matrix plot
  TCanvas* c_smear = new TCanvas;
  c_smear->SetBottomMargin( 0.15 );
  c_smear->SetLeftMargin( 0.13 );

  if ( show_smear_numbers ) {
    // Round all numbers to this precision when rendering them
    gStyle->SetPaintTextFormat( "4.2f" );

    smear_hist->Draw("text colz");
  }
  else {
    smear_hist->Draw( "colz" );
  }

  // Draw a vertical red line to separate the signal true bins from the
  // background true bins in the smearing matrix plot. Start by finding
  // where the first background bin is. Here we assume that the full set
  // of signal bins comes before any background bins.
  const auto& true_bins = rmm.true_bins();
  size_t num_true_bins = true_bins.size();
  size_t first_bkgd_bin_idx = num_true_bins;
  for ( size_t t = 0u; t < num_true_bins; ++t ) {
    const auto& tbin = true_bins.at( t );
    if ( tbin.type_ == TrueBinType::kBackgroundTrueBin ) {
      first_bkgd_bin_idx = t;
      break;
    }
  }

  // We've found the bin index. Now draw the line to indicate the
  // signal/background boundary in true space
  TLine* bkgd_line = new TLine( first_bkgd_bin_idx, 0.,
    first_bkgd_bin_idx, num_reco_bins );

  bkgd_line->SetLineColor( kRed );
  bkgd_line->SetLineWidth( 3 );
  bkgd_line->SetLineStyle( 2 );
  bkgd_line->Draw( "same" );

  // For each true bin, print the fraction of events that are reconstructed
  // in the correct corresponding reco bin.
  for ( int bb = 1; bb <= num_reco_bins; ++bb ) {
    std::cout << "bin #" << bb << ": "
	      << expected_reco_hist->GetBinLowEdge( bb ) << " -> " << expected_reco_hist->GetBinLowEdge( bb+1 ) << " , "
	      << smear_hist->GetBinContent(bb, bb) << '\n';
  }

}

void MakeMigrationMatrix() {

  std::cout << "===================================================================================================================" << std::endl;

  make_res_plots( 
		 "CC1mu2p0pi_Reco_Pt", 
		 "DeltaPT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.0 }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_Pt",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  make_res_plots( 
		 "CC1mu2p0pi_Reco_Pt", 
		 "DeltaPT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 0.2, 0.4, 0.6, 1.0 }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_Pt",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  make_res_plots( 
		 "CC1mu2p0pi_Reco_Pt", 
		 "DeltaPT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 0.15, 0.3, 0.45, 0.6, 1.0 }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_Pt",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  std::cout << "===================================================================================================================" << std::endl;

  make_res_plots( 
		 "CC1mu2p0pi_Reco_DeltaAlphaT", 
		 "DeltaAlphaT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 30., 60., 90., 120., 150., 180. }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_DeltaAlphaT",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  make_res_plots( 
		 "CC1mu2p0pi_Reco_DeltaAlphaT", 
		 "DeltaAlphaT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 20., 55., 90., 125., 160., 180. }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_DeltaAlphaT",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  make_res_plots( 
		 "CC1mu2p0pi_Reco_DeltaAlphaT", 
		 "DeltaAlphaT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 15., 50., 85., 125., 160., 180. }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_DeltaAlphaT",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  std::cout << "===================================================================================================================" << std::endl;

  make_res_plots( 
		 "CC1mu2p0pi_Reco_DeltaPhiT", 
		 "DeltaPhiT", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { 0., 30., 60., 90., 120., 150., 180. }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_DeltaPhiT",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  std::cout << "===================================================================================================================" << std::endl;

  make_res_plots( 
		 "CC1mu2p0pi_Reco_CosPlPr", 
		 "CosPlPr", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { -1.0, -0.75, -0.5, -0.25, 0., 0.25, 0.5, 0.75, 1.0 }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_CosPlPr",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);

  std::cout << "===================================================================================================================" << std::endl;

  make_res_plots( 
		 "CC1mu2p0pi_Reco_CosMuPsum", 
		 "CosMuPsum", 
		 "CC1mu2p0pi_Selected", 
		 {1,2,3},
		 { -1.0, -0.75, -0.5, -0.25, 0., 0.25, 0.5, 0.75, 1.0 }, 
		 false,
		 false,
		 DEFAULT_TRUE_BINS,
		 "CC1mu2p0pi_True_CosMuPsum",
		 "CC1mu2p0pi_MC_Signal",
		 DEFAULT_MC_EVENT_WEIGHT);



}

int main() {
  MakeMigrationMatrix();
}
